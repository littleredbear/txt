why??????????
将函数参数设定为const的引用保证了函数可以用于不能拷贝的类型。
当我们调用一个函数时，编译器只需掌握函数的声明。当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而函数的定义放在源文件中。
模板则不同，要生成一个实例化版本，编译器需要掌握模板的定义。因此，模板的头文件通常既包含声明也包括定义。




extern "C"	使用c编译方式。不对函数名进行修饰。

void foo(int x, inty);
该函数被C编译器编译后在符号库中的名字为_foo, 而c++编译器则产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名，函数参数数量及类型信息，c++就是靠这种机制来实现函数重载的。

面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于，OOP能处理类型在程序运行之前都未知的情况，泛型编程在编译时就能知道。

调用模版函数时，编译器会生成模版的实例。
模版类型参数：
template <typename T, typename U>	
T calc(const T&, const U&);

非类型模版参数：一个非类型参数表示一个值而非一个类型。
当一个模版被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], cosnt char (&p2)[M])
{
	return strcmp(p1, p2);
}
compare("hi", "mom");






